#########################################
if(is.null(given) | is.null(reference_model$posterior_distribution)) {
using <- "priors"
if(!is.null(reference_model$prior_distribution)) {if(nrow(reference_model$prior_distribution) > sims) {
reference_model$prior_distribution <- reference_model$prior_distribution[1:sims,]}}
if(!is.null(reference_model$prior_distribution)) {if(nrow(model$prior_distribution) < sims) {
stop("model contains priors distribution with too few parameter draws")}}
if(is.null(reference_model$prior_distribution)) reference_model <-  set_prior_distribution(reference_model, sims)
param_dist <- reference_model$prior_distribution[1:sims,]
} else {
using <- "posteriors"
param_dist <- rstan::extract(reference_model$posterior, pars= "lambdas")$lambdas
}
# 3 ESTIMANDS DATABASE: If not provided, this gets generated using reference model and queries
##################################################################################
if(is.null(estimands_database)) {
# Distribution of causal types
type_distribution <- draw_type_prob_multiple(reference_model, using = using)
# sims * length(queries) matrix of estimands
estimands_database <- mapply(query_distribution, model = list(reference_model), query = queries, using = using, type_distribution = list(type_distribution))
}
# 4 POSSIBLE DATA: Generate if not provided
##################################################################################
# list of possible_data given different strategies: Can handle multiple data strategies
if(is.null(possible_data_list)){
possible_data_list = lapply(data_strategies, function(ds)
with(ds,
make_possible_data(model = reference_model, given = given, N = N, within = within, condition = conditions, vars = vars)))
}
data_probabilities_list <-
lapply(possible_data_list, function(possible_data)
apply(param_dist, 1, function(pars) {  # FLAG NEEDS TO WORK WITH POSTERIOR ALSO
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data)}))
# 6 ESTIMATES DISTRIBUTION: ESTIMAND FOR EACH QUERY FROM UPDATED DATA
##################################################################################################
if(is.null(estimates_database)) {
estimates_database <- lapply(possible_data_list, function(possible_data){
make_estimates_database(analysis_model, given = given, possible_data = possible_data,
queries = queries, subsets = subsets, expand_grid = expand_grid)
})
}
estimates_database
possible_data_list
data_probabilities_list
possible_data_list
possible_data <- possible_data_list[[1]]
dim(param_dist)
if(is.null(given) | is.null(reference_model$posterior_distribution)) {
using <- "priors"
if(!is.null(reference_model$prior_distribution)) {if(nrow(reference_model$prior_distribution) > sims) {
reference_model$prior_distribution <- reference_model$prior_distribution[1:sims,]}}
if(!is.null(reference_model$prior_distribution)) {if(nrow(model$prior_distribution) < sims) {
stop("model contains priors distribution with too few parameter draws")}}
if(is.null(reference_model$prior_distribution)) reference_model <-  set_prior_distribution(reference_model, sims)
param_dist <- reference_model$prior_distribution[1:sims,]
} else {
using <- "posteriors"
param_dist <- rstan::extract(reference_model$posterior, pars= "lambdas")$lambdas
}
dim(param_dist)
if(is.null(given) | is.null(reference_model$posterior_distribution)) {
using <- "priors"
if(!is.null(reference_model$prior_distribution)) {if(nrow(reference_model$prior_distribution) > sims) {
reference_model$prior_distribution <- reference_model$prior_distribution[1:sims,]}}
if(!is.null(reference_model$prior_distribution)) {if(nrow(model$prior_distribution) < sims) {
stop("model contains priors distribution with too few parameter draws")}}
if(is.null(reference_model$prior_distribution)) reference_model <-  set_prior_distribution(reference_model, sims)
param_dist <- reference_model$prior_distribution
} else {
using <- "posteriors"
param_dist <- (rstan::extract(reference_model$posterior, pars= "lambdas")$lambdas)[1:sims,]
}
dim(param_dist)
A_w <- (get_likelihood_helpers(reference_model)$A_w)[possible_data$event, ]
data_probabilities_list <-
lapply(possible_data_list, function(possible_data)
apply(param_dist, 1, function(pars) {  # FLAG NEEDS TO WORK WITH POSTERIOR ALSO
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data,
A_w  = A_w )}))
library(gbiqqtools)
A_w <- (get_likelihood_helpers(reference_model)$A_w)[possible_data$event, ]
data_probabilities_list <-
lapply(possible_data_list, function(possible_data)
apply(param_dist, 1, function(pars) {  # FLAG NEEDS TO WORK WITH POSTERIOR ALSO
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data,
A_w  = A_w )}))
param_dist
possible_data_list
possible_data
pars <- param_dist[1,]
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data,
A_w  = A_w )})
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data,
A_w  = A_w )
A_w
data_probabilities_list <-
lapply(possible_data_list, function(possible_data)
apply(param_dist, 1, function(pars) {  # FLAG NEEDS TO WORK WITH POSTERIOR ALSO
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data,
A_w  = A_w )}))
knitr::opts_chunk$set(echo = TRUE)
library(gbiqq)
library(gbiqqtools)
models <- c("M1", "M2", "M3")
data_types <- c("D1", "D2", "D3")
strategies <- c("S1", "S2", "S3")
experiments_list <- expand.grid(models. data_types, strategies)
experiments_list <- expand.grid(models, data_types, strategies)
experiments_list
M1 <- make_model("X -> K -> Y")
simulate_data(M1)
text = paste("simulate_data(, model_name", ")")
text
text = paste("simulate_data(", model_name", ")")
text = paste0("simulate_data(", model_name, ")")
model_name = "M1"
text = paste0("simulate_data(", model_name, ")")
text
eval(parse(text = text))
text
rm(list = ls())
if(!exists("fit")) fit  <- fitted_model()
reference_model = NULL
analysis_model <-
make_model("X->M->Y")  %>%
set_restrictions(c("Y[M=1]<Y[M=0]", "M[X=1]<M[X=0]")) %>%
set_parameter_matrix()
df      <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
given   <- collapse_data(df, analysis_model, remove_family = TRUE)
queries <- "Y[X=1]>Y[X=0]"
subsets <- TRUE # Subsets for queries
expand_grid <- FALSE  # For queries
estimands_database <- NULL
estimates_database <- NULL
possible_data_list <- NULL
sims <- 30
data_strategies <- list(strategy1 = list(N=1, within = TRUE, vars = "M", conditions = list("Y==1 & X==1")),
strategy2 = list(N=1, within = TRUE, vars = "M", conditions = list("Y==X")))
diagnosis <- diagnose_strategies(
analysis_model = analysis_model,
data_strategies = data_strategies,
given = given,
queries = queries,
subsets = subsets,
sims = sims)
model <- make_model("X -> M -> Y")
model1 <- set_restrictions(model, labels = c(M = 10))
model1 <- set_restrictions(model, "M[X=0] > M[X=1]")
model2 <- set_restrictions(model, "Y[M=0] > Y[M=1]")
model2
query_model(model1, query = "Y[X=0] > Y[X=1]", subsets = ("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
query_model(model1, query = "Y[X=0] > Y[X=1]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
? query_model
query_model(model1, queries = "Y[X=0] > Y[X=1]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
model <- make_model("X -> M -> Y")
model1 <- set_restrictions(model, "M[X=0] > M[X=1]")
model2 <- set_restrictions(model, "Y[M=0] > Y[M=1]")
query_model(model1, queries = "Y[X=1] > Y[X=0]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
query_model(model2, queries = "Y[X=1] > Y[X=0]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
model <- make_model("X -> M -> Y")
models <- list(
set_restrictions(model, "M[X=0] > M[X=1]")
set_restrictions(model, "Y[M=0] > Y[M=1]")
set_restrictions(model, "Y[M=0] > Y[M=1]", "M[X=0] > M[X=1]"))
lapply(models,
query_model, queries = "Y[X=1] > Y[X=0]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
models <- list(
set_restrictions(model, "M[X=0] > M[X=1]")
set_restrictions(model, "Y[M=0] > Y[M=1]")
set_restrictions(model, "Y[M=0] > Y[M=1]", "M[X=0] > M[X=1]"))
models <- list(
set_restrictions(model, "M[X=0] > M[X=1]"),
set_restrictions(model, "Y[M=0] > Y[M=1]"),
set_restrictions(model, "Y[M=0] > Y[M=1]", "M[X=0] > M[X=1]"))
lapply(models,
query_model, queries = "Y[X=1] > Y[X=0]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
model <- make_model("X -> M -> Y")
models <- list(
set_restrictions(model, "M[X=0] > M[X=1]"),
set_restrictions(model, "Y[M=0] > Y[M=1]"),
set_restrictions(model, "Y[M=0] > Y[M=1]", "M[X=0] > M[X=1]"))
lapply(models,
query_model, queries = "Y[X=1] > Y[X=0]", subsets = c("X == 1 & Y ==1", "X == 1 & Y ==1 & M ==1", "X == 1 & Y ==1 & M ==0"))
model <- make_model("X -> M1 -> M2 -> M3 -> Y")
model <-set_restrictions(model, c("Y[M3=0] > Y[M3=1]", "M3[M2=0] > M3[M2=1]", "M2[M1=0] > M2[M1=1]", "M1[X=0] > M2[X=1]")
query_model(model, queries = "Y[X=1] > Y[X=0]", subsets = c("X == 1 & Y ==1",
"X == 1 & Y ==1 & M1 == 1",
"X == 1 & Y ==1 & M1 == 0",
"X == 1 & Y ==1 & M2 == 1",
"X == 1 & Y ==1 & M2 == 0"))
subsets = c("X == 1 & Y ==1",
"X == 1 & Y ==1 & M1 == 1",
"X == 1 & Y ==1 & M1 == 0",
"X == 1 & Y ==1 & M2 == 1",
"X == 1 & Y ==1 & M2 == 0")
model <- make_model("X -> M1 -> M2 -> M3 -> Y")
model <- set_restrictions(model, c("Y[M3=0] > Y[M3=1]", "M3[M2=0] > M3[M2=1]", "M2[M1=0] > M2[M1=1]", "M1[X=0] > M2[X=1]")
)
model <- make_model("X -> M1 -> M2 -> M3 -> Y")
model <- set_restrictions(model, c("Y[M3=0] > Y[M3=1]", "M3[M2=0] > M3[M2=1]", "M2[M1=0] > M2[M1=1]", "M1[X=0] > M1[X=1]"))
query_model(model,
queries = "Y[X=1] > Y[X=0]",
subsets = c("X == 1 & Y ==1",
"X == 1 & Y ==1 & M1 == 1",
"X == 1 & Y ==1 & M1 == 0",
"X == 1 & Y ==1 & M2 == 1",
"X == 1 & Y ==1 & M2 == 0"))
model <- make_model("X -> M1 -> M2 -> M3 -> M4 -> M5-> Y")
model <- set_restrictions(model, c("Y[M5=0] > Y[M5=1]",
"M5[M4=0] > M5[M4=1]",
"M4[M3=0] > M4[M3=1]",
"M3[M2=0] > M3[M2=1]",
"M2[M1=0] > M2[M1=1]",
"M1[X=0] > M1[X=1]"))
query_model(model,
queries = "Y[X=1] > Y[X=0]",
subsets = c("X == 1 & Y ==1",
"X == 1 & Y ==1 & M1 == 1",
"X == 1 & Y ==1 & M1 == 0",
"X == 1 & Y ==1 & M3 == 1",
"X == 1 & Y ==1 & M3 == 0"))
library(gbiqqtools)
# Example comparing two data strategies
rm(list = ls())
if(!exists("fit")) fit  <- fitted_model()
reference_model = NULL
analysis_model <-
make_model("X->M->Y")  %>%
set_restrictions(c("Y[M=1]<Y[M=0]", "M[X=1]<M[X=0]")) %>%
set_parameter_matrix()
df      <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
given   <- collapse_data(df, analysis_model, remove_family = TRUE)
queries <- "Y[X=1]>Y[X=0]"
subsets <- TRUE # Subsets for queries
expand_grid <- FALSE  # For queries
estimands_database <- NULL
estimates_database <- NULL
possible_data_list <- NULL
sims <- 30
data_strategies <- list(strategy1 = list(N=1, within = TRUE, vars = "M", conditions = list("Y==1 & X==1")),
strategy2 = list(N=1, within = TRUE, vars = "M", conditions = list("Y==X")))
diagnosis <- diagnose_strategies(
analysis_model = analysis_model,
data_strategies = data_strategies,
given = given,
queries = queries,
subsets = subsets,
sims = sims)
# 1. REFERENCE MODEL
# If not provided, reference model should be the analysis model, updated
if(is.null(reference_model)) {
if(is.null(given)) {
reference_model <- analysis_model
} else {
data <- expand_data(given, analysis_model)
reference_model <- gbiqq(analysis_model, data, stan_model = fit)
}}
# 2. REFERENCE PARAMETERS DISTRIBUTION
#########################################
if(is.null(given) | is.null(reference_model$posterior_distribution)) {
using <- "priors"
if(!is.null(reference_model$prior_distribution)) {if(nrow(reference_model$prior_distribution) > sims) {
reference_model$prior_distribution <- reference_model$prior_distribution[1:sims,]}}
if(!is.null(reference_model$prior_distribution)) {if(nrow(model$prior_distribution) < sims) {
stop("model contains priors distribution with too few parameter draws")}}
if(is.null(reference_model$prior_distribution)) reference_model <-  set_prior_distribution(reference_model, sims)
param_dist <- reference_model$prior_distribution
} else {
using <- "posteriors"
param_dist <- (rstan::extract(reference_model$posterior, pars= "lambdas")$lambdas)[1:sims,]
}
# 3 ESTIMANDS DATABASE: If not provided, this gets generated using reference model and queries
##################################################################################
if(is.null(estimands_database)) {
# Distribution of causal types
type_distribution <- draw_type_prob_multiple(reference_model, using = using)
# sims * length(queries) matrix of estimands
estimands_database <- mapply(query_distribution, model = list(reference_model), query = queries, using = using, type_distribution = list(type_distribution))
}
# 4 POSSIBLE DATA: Generate if not provided
##################################################################################
# list of possible_data given different strategies: Can handle multiple data strategies
if(is.null(possible_data_list)){
possible_data_list = lapply(data_strategies, function(ds)
with(ds,
make_possible_data(model = reference_model, given = given, N = N, within = within, condition = conditions, vars = vars)))
}
# 5 POSSIBLE DATA DISTRIBUTION: FOR EACH STRATEGY nrow(possible_data) * sims matrix of data probabilities
##################################################################################################
## FLAG: THIS FUNCTION IS THE SLOWEST STEP: HOW TO SPEED UP?
data_probabilities_list <-
lapply(possible_data_list, function(possible_data) {
A_w <- (get_likelihood_helpers(reference_model)$A_w)[possible_data$event, ]
apply(param_dist, 1, function(pars) {  # FLAG NEEDS TO WORK WITH POSTERIOR ALSO
make_data_probabilities(
reference_model,
pars = pars,
possible_data = possible_data,
A_w  = A_w )})})
# 6 ESTIMATES DISTRIBUTION: ESTIMAND FOR EACH QUERY FROM UPDATED DATA
##################################################################################################
if(is.null(estimates_database)) {
estimates_database <- lapply(possible_data_list, function(possible_data){
make_estimates_database(analysis_model, given = given, possible_data = possible_data,
queries = queries, subsets = subsets, expand_grid = expand_grid)
})
}
# 7 MAGIC: Calculate diagnostics for each data strategy
##################################################################################################
estimands <- apply(estimands_database, 2, mean)
estimands
estimands_database
mean
estimands_database
estimates_database
length(estimates_database)
diagnosis <-
lapply(1:length(estimates_database), function(j) {
mate <- estimates_database[[j]]
# Error if each datatype observed  n_query * n_data_possibilities
estimate <- sapply(1:length(mate), function(i)  mate[[i]]$mean)
error    <- sapply(1:length(mate), function(i) {mate[[i]]$mean - estimands})
sq_error <- error^2
post_var <- sapply(1:length(mate), function(i) (mate[[i]]$sd)^2)
prob <- data_probabilities_list[[j]]
# Return
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
query = names(queries),
subsets = subsets)
})
j = 1
mate <- estimates_database[[j]]
mate
estimate <- sapply(1:length(mate), function(i)  mate[[i]]$mean)
error    <- sapply(1:length(mate), function(i) {mate[[i]]$mean - estimands})
sq_error <- error^2
post_var <- sapply(1:length(mate), function(i) (mate[[i]]$sd)^2)
prob <- data_probabilities_list[[j]]
prob
length(estimates_database)
estimate
prob
estimate%*%prob
estimate = apply(estimate%*%prob, 1, mean)
MSE      = apply(sq_error%*%prob, 1, mean)
post_var = apply(post_var%*%prob, 1, mean)
strategy = j
query = names(queries)
query
strategy
post_var
MSE
estimate
estimand
estimand = estimands
estimand
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
query = names(queries),
subsets = subsets)
estimate
apply(estimate%*%prob, 1, mean)
apply(estimate%*%prob, 1, mean)
apply(sq_error%*%prob, 1, mean)
sq_error
estimate
estimate <- sapply(1:length(mate), function(i)  mate[[i]]$mean)
error    <- sapply(1:length(mate), function(i) {mate[[i]]$mean - estimands})
sq_error <- error^2
post_var <- sapply(1:length(mate), function(i) (mate[[i]]$sd)^2)
prob <- data_probabilities_list[[j]]
# Return
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
query = names(queries),
subsets = subsets)
})
estimate <- sapply(1:length(mate), function(i)  mate[[i]]$mean)
error    <- sapply(1:length(mate), function(i) {mate[[i]]$mean - estimands})
sq_error <- error^2
post_var <- sapply(1:length(mate), function(i) (mate[[i]]$sd)^2)
prob <- data_probabilities_list[[j]]
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
query = names(queries),
subsets = subsets)
estimands
apply(estimate%*%prob, 1, mean)
apply(sq_error%*%prob, 1, mean)
j
names(queries)
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
#			query = names(queries),
subsets = subsets)
names(queries)
queries
query = queries
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
query = queries,
subsets = subsets)
diagnosis <-
lapply(1:length(estimates_database), function(j) {
mate <- estimates_database[[j]]
# Error if each datatype observed  n_query * n_data_possibilities
estimate <- sapply(1:length(mate), function(i)  mate[[i]]$mean)
error    <- sapply(1:length(mate), function(i) {mate[[i]]$mean - estimands})
sq_error <- error^2
post_var <- sapply(1:length(mate), function(i) (mate[[i]]$sd)^2)
prob <- data_probabilities_list[[j]]
# Return
data.frame(
estimand = estimands,
estimate = apply(estimate%*%prob, 1, mean),       # Average over draw
MSE      = apply(sq_error%*%prob, 1, mean),
post_var = apply(post_var%*%prob, 1, mean),
strategy = j,
query = queries,
subsets = subsets)
})
diagnosis
return_list <- list()
return_list$diagnoses_df        <- diagnosis
return_list$possible_data       <- possible_data
return_list$estimands_database  <- estimands_database
return_list$estimates_database  <- estimates_database
return_list$data_probabilities_list  <-  data_probabilities_list
return_list
library(gbiqqtools)
# Example comparing two data strategies
rm(list = ls())
if(!exists("fit")) fit  <- fitted_model()
reference_model = NULL
analysis_model <-
make_model("X->M->Y")  %>%
set_restrictions(c("Y[M=1]<Y[M=0]", "M[X=1]<M[X=0]")) %>%
set_parameter_matrix()
df      <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
given   <- collapse_data(df, analysis_model, remove_family = TRUE)
queries <- "Y[X=1]>Y[X=0]"
subsets <- TRUE # Subsets for queries
expand_grid <- FALSE  # For queries
estimands_database <- NULL
estimates_database <- NULL
possible_data_list <- NULL
sims <- 30
data_strategies <- list(strategy1 = list(N=1, within = TRUE, vars = "M", conditions = list("Y==1 & X==1")),
strategy2 = list(N=1, within = TRUE, vars = "M", conditions = list("Y==X")))
diagnosis <- diagnose_strategies(
analysis_model = analysis_model,
data_strategies = data_strategies,
given = given,
queries = queries,
subsets = subsets,
sims = sims)
return_list <- list()
return_list$diagnoses_df        <- diagnosis
return_list$possible_data_list       <- possible_data_list
return_list$estimands_database  <- estimands_database
return_list$estimates_database  <- estimates_database
return_list$data_probabilities_list  <-  data_probabilities_list
diagnosis <- diagnose_strategies(
analysis_model = analysis_model,
data_strategies = data_strategies,
given = given,
queries = queries,
subsets = subsets,
sims = sims)

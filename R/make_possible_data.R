#' Make data for multi-step strategy
#'
#' Creates a database of possible data from a data strategy.
#' Users can gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"). Or they can
#' gather data in all cases within a given dataset ("within"). Or they can specify  the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#'
#' @param model A causal model object generated by \code{make_model}.
#' @param given A data.frame with observations.
#' @param N An integer. Number of variables to seek.
#' @param withins A list of logicals. Whether to seek variables within existing data. Defaults to TRUE.
#' @param conditions  A list of character strings indicating for which cases data should be gathered. Options are: (i) to gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"), (ii) to gather data in all cases within a given dataset ("within"), or (iii) to specify the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#' @param vars A character vector. Variables to be sought or NA. If NA \code{make_possible_data} gathers data on all variables containing NA for the specified data strategy.
#' @param prefix for columns of output; useful if multiple dataframes are later merged
#' @export
#' @return A dataset with columns: event, strategy, plus possibly multiple cases profiles
#' @examples
#' model <- make_model("X->M->Y")  %>%
#'    set_restrictions(c("Y[M=1]<Y[M=0]"), "(M[X=1]<M[X=0] ") %>%
#'    set_parameter_matrix()
#' df <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
#' given <- collapse_data(df, model)[, -2]
#'
#' # Complex *not within*
#' make_possible_data(model, N=list(1,2), withins = FALSE, vars = list(c("X", "Y"), c("X")), conditions = TRUE)
#'
#' # Complex, sequential: not within, then within
#' make_possible_data(model, N=list(1,1), given = given,
#'              withins = c(FALSE, TRUE),
#'              vars = list(c("X", "Y"), c("M")),
#'              conditions = TRUE)
#'
#' # Look for data on M for all possible cases in the given data
#' make_possible_data(model, N = 0, within = FALSE)
#' make_possible_data(model, N = 2, within = FALSE)
#' make_possible_data(model, given = given, vars = "M", N = 2, conditions = c("X==Y"))
#' make_possible_data(model, given = given, vars = "M", N = list(1,1), conditions = list("X==Y", "X==Y"))
#'
#' # Not possible:
#' make_possible_data(model, given, vars = "M", within = TRUE, N = 7)
#'
#' # Partly possible: only one step completed
#' model2 <- make_model("A -> B -> C -> D")
#' given2 <- data.frame(A = c(0,0,0,1,1,1), B = NA, C = NA, D = c(0,0,1,0,1,1)) %>%
#'   collapse_data(model2, remove_family = TRUE)
#' make_possible_data(model2, given2, vars = list("B", "C"), within = TRUE, N = list(1,1), conditions = list("A==D", "A==D & B==1"))
#'
#' # Within conditions
#' make_possible_data(model, given, within = TRUE, N = 2, conditions = "X==1 & Y==1", vars = "M")
#'
#' # Look for data on K but not M
#' model <- make_model("X->M->Y <-K")   %>%
#'    set_parameter_matrix()
#' df <- data.frame(X = c(0,0,1,1,1), K = NA, M = NA, Y = c(0,0,0,1,1))
#' given <- collapse_data(df, model)[, -2]
#' make_possible_data(model, given, within = TRUE, N = 1, vars = "K")
#'
#'
#' # From book
#'
#' model <- make_model("X->M->Y")  %>%
#'  set_restrictions(c("(Y[M=1]<Y[M=0])", "(M[X=1]<M[X=0])")) %>%
#' 	set_parameter_matrix() %>%
#' 	set_parameters(type = "flat")
#'
#' 	given <-  collapse_data(data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1)),
#' 													model, remove_family = TRUE)
#' 	make_possible_data(model,
#'  	given = given,
#'  	vars = list("M", "M", "M", "M"),
#'  	within = TRUE,
#'  	N = list(1,1,1,1),
#'  	conditions = list("X==0 & Y==0", "X==1 & Y==0", "X==0 & Y==1", "X==1 & Y==1"))

make_possible_data <- function(model,
															 given = NULL,
															 N = list(1),
															 withins = TRUE,
															 conditions = list(TRUE),
															 vars = NULL,
															 prefix = NULL) {

	if(is.null(vars)) vars <- list(model$variables)

	if(is.null(given)) given <- gbiqq:::minimal_event_data(model)

	if("strategy" %in% names(given)) given <- dplyr::select(given, - strategy)

	if(!is.null(given)) if(!identical(names(given), c("event", "count"))){
		stop("'given' df should have two columns: event and count")}


	if(length(vars)==1 & (length(N)>1)) vars <- rep(vars, length(N))
	if(length(withins)==1 & (length(N)>1)) withins <- rep(withins, length(N))
	if(length(conditions)==1 & (length(N)>1)) conditions <- rep(conditions, length(N))
	if(!identical(length(conditions), length(N)) )
		stop("N, and conditions  must have the same length")


	if(is.null(given) & withins[1]) {message("No data given; 'withins' changed to FALSE"); withins[1] <- FALSE}

		if(!identical(length(vars), length(N)) )
		stop("Vars should be of length 1 or else have the same length as conditions  and N")

	g_df <- gbiqqtools:::make_possible_data_single(
		model,
		given = given,
		withins = withins[[1]],
		N = N[[1]],
		conditions = conditions[[1]],
		vars = vars[[1]] )


	if(length(N) == 1){
		attr(g_df, "possible_data_args") <- list(N = N,withins = withins, conditions = conditions, vars = vars)
		g_df <- (gbiqqtools:::check_event_data(g_df, model))
		colnames(g_df)[-c(1:2)] <- 1:(ncol(g_df)-2)

		return(g_df)
	}


	for (i in 2:length(N)){

		out <- lapply(2:ncol(g_df), function(s) {
			use_df <-  g_df[,c(1,s)]
			names(use_df)  <- c("event", "count")
			data_single <- make_possible_data_single(model,
																							 given = 	use_df,
																							 withins = withins[[i]],
																							 N     = N[[i]],
																							 conditions = conditions[[i]],
																							 vars  = vars[[i]])

			colnames(data_single)[2:ncol(data_single)] <- paste0(s-1, "-", colnames(data_single)[2:ncol(data_single)])
			data_single
		})

		out   <- Reduce(function(x, y) merge(x, y,  by = c("event"), all = TRUE), 	out)
		g_df  <- dplyr:::mutate_if(out, is.numeric, ~replace(., is.na(.), 0))

	}

	if(!is.null(prefix)) names(g_df)[-1] <- paste0(prefix, "_", names(g_df)[-1])

	g_df <- check_event_data(g_df, model)

	g_df[,!duplicated(t(g_df))]

	colnames(g_df)[-c(1:2)] <- 1:(ncol(g_df)-2)

	g_df
}




#' Make possible data for a single strategy step
#'
#' Creates a database of possible data from a data strategy.
#' Users can gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"). Or they can
#' gather data in all cases within a given dataset ("withins"). Or they can specify  the subset of cases for which withins-case data should be collected (e.g. "Y == 1").
#'
#' @param model A causal model as created by \code{make_model}
#' @param given A data frame in compact form with first column indicating event type and second column indicating number of events of that type.
#' @param N Number of variables to seek
#' @param withins logical Whether to seek variables within existing data
#' @param conditions  A list of character strings indicating for which cases data should be gathered. Options are: (i) to gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"), (ii) to gather data in all cases within a given dataset ("within"), or (iii) to specify the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#' @param vars Variables to be sought or NA. If NA \code{make_possible_data} gathers data on all variables containing NA for the specified data strategy.
#' @export
#' @return A dataset
#' @examples
#' model <- make_model("X->M->Y")  %>%
#'    set_restrictions(c("Y[M=1]<Y[M=0]", "M[X=1]<M[X=0]")) %>%
#'    set_parameter_matrix()
#' df <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
#' given <- collapse_data(df, model, remove_family = TRUE)
#'
#' make_possible_data_single(model, given = given, vars = "M", within = TRUE, N = 2)

make_possible_data_single <- function(model,
																			given = NULL,
																			N = 1,
																			withins = FALSE,
																			conditions = TRUE,
																			vars = NULL) {

	if(is.null(vars) & withins) stop("Please specify vars to be examined")

	if(withins & is.null(given)) stop("If 'withins' is specified 'given' must be provided")

	if(is.null(given)) given <- gbiqq:::minimal_event_data(model)[,-2]

	if(N==0 & withins) return(given)

	# If not withins simply select possible data
	if(!withins) return(
		gbiqqtools:::complex_combine(list(
			given,
		  new = gbiqqtools:::all_possible(model, N, vars) %>% dplyr::select(-count))))


	# Otherwise its more complicated: select from *within* available data
	if(is.null(given)) stop("given not provided, but 'withins' requested")

	# all_event_types <- collapse_data(all_data_types(model), model, remove_family = TRUE)

	possible <- all_data_types(model) %>%
		filter(eval(parse(text = conditions))) %>%
		mutate(event = as.character(event))

	# This part to allow searching in cases where there is space to seek listed vars
	possible <- possible[apply(possible[vars], 1, function(j) all(is.na(j))),]

	all_buckets <- left_join(dplyr::select(possible, event), given, by = "event")[c("event", "count")]
	all_buckets$count[is.na(all_buckets$count)] <-0
	all_buckets <- mutate(all_buckets, capacity = count)

	if(sum(all_buckets$capacity) < N) {message("Not enough units to allocate N.
																						 Perhaps you are seeking data within cases in which data is already observed?"); return(given)}

	strategies <- as.matrix(partitions::blockparts(all_buckets$capacity, N))
		colnames(strategies) <- 1:ncol(strategies)
		all_buckets <- cbind(all_buckets, strategies)

		# This function goes through a bucket strategy and generates all possible datasets
		# that could be produced by the strategy
		##################################################################################
		get_results_from_strategy <- function(strategy){
			buckets          <- all_buckets[all_buckets$capacity>0 ,]
			buckets          <- buckets[buckets[,strategy]>0, c(1:3, strategy)]
			data_list        <- lapply(1:nrow(buckets), function(j)   fill_bucket(model, buckets, vars, row = j, column = 4))

      # If cases have been drawn from within set, remove these now
			if(withins) data_list[["remove_bucket"]] <- data.frame(event = buckets$event, x = -(buckets$capacity))

			data_list[["given"]] <- given

			out <- gbiqqtools:::complex_combine(data_list)

			names(out)[-1] <-paste0(strategy-3, ".",  1:(ncol(out)-1))
			out

		}

		# Run over all strategies
		all_strategies <- sapply(4:ncol(all_buckets), function(s) get_results_from_strategy(s),
														 simplify = FALSE)
		out <- Reduce(function(x, y) merge(x, y,  by = "event", all = TRUE), all_strategies) %>%
			mutate_if(is.numeric, ~replace(., is.na(.), 0))

		out$event <- as.character(out$event)

  	out

  }


#'  Complex combine
#'
#'  Used to combine permutations of rows of dataframes in a list
#'
#'  @param data_list list of dataframes. All dataframes should contain event column but have unique event elements
#'  @examples
#'  data_list <- list(
#'  data.frame(event = c("a", "b"), w = 1:2, x = 3:4),
#'  data.frame(event = c("c", "d", "e"), y = 5:7, z = 8:10, q = 11:13))
#'  complex_combine(data_list)
#'
#'  data_list <- list(
#'  data.frame(event = c("a", "b"), w = 1:2, x = 3:4),
#'  data.frame(event = c("c", "d", "b"), y = 5:7, z = 8:10, q = 11:13))
#'  complex_combine(data_list)


complex_combine <- function(data_list) {

	locations <- perm(unlist(lapply(data_list, ncol)) - 2)

	dfs <- lapply(1:nrow(locations), function(i) {
		parts <-  lapply(1:length(data_list), function(j) {
			df <- data_list[j][[1]][, c(1, locations[i,j][[1]]+2)]
			names(df) <- c("event", "cases")
			df
		})
		out <- do.call("rbind", parts)
		out <- aggregate(cases ~ event, data = out, sum)
		names(out) <- c("event", i)
		out
	})
		Reduce(function(x, y) merge(x, y,  by = "event", all = TRUE), dfs)
 }


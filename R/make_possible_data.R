#' Make data for multi-step strategy
#'
#' Creates a database of possible data from a data strategy.
#' Users can gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"). Or they can
#' gather data in all cases within a given dataset ("within"). Or they can specify  the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#'
#' @param model A causal model object generated by \code{make_model}.
#' @param given A data.frame with observations.
#' @param N An integer. Number of variables to seek.
#' @param within Logical. Whether to seek variables within existing data. Defaults to TRUE.
#' @param condition  A list of character strings indicating for which cases data should be gathered. Options are: (i) to gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"), (ii) to gather data in all cases within a given dataset ("within"), or (iii) to specify the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#' @param vars A character vector. Variables to be sought or NA. If NA \code{make_possible_data} gathers data on all variables containing NA for the specified data strategy.
#' @param prefix for columns of output; useful if multiple dataframes are later merged
#' @export
#' @return A dataset
#' @examples
#' library(dplyr)
#' model <- make_model("X->M->Y")  %>%
#'    set_restrictions(c("Y[M=1]<Y[M=0]"), "(M[X=1]<M[X=0] ") %>%
#'    set_parameter_matrix()
#' df <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
#' given <- collapse_data(df, model)[, -2]
#'
#' # Look for data on M for all possible cases in the given data
#' make_possible_data(model, N = 0, within = FALSE)
#' make_possible_data(model, N = 2, within = FALSE)
#' make_possible_data(model, given, vars = list("M"), within = TRUE, N = 2)
#'
#' # Not possible:
#' make_possible_data(model, given, vars = "M", within = TRUE, N = 7)
#'
#' # Within conditions
#' make_possible_data(model, given, within = TRUE, N = 2, condition = "X==1 & Y==1", vars = "M")
#' make_possible_data(model, given, within = TRUE, N = 3, condition = "Y==1", vars = "M")
#' make_possible_data(model, given, within = TRUE, condition = "X == 1 | Y == 1", vars = "M")
#'
#' # Look for data on K but not M
#' model <- make_model("X->M->Y <-K")   %>%
#'    set_parameter_matrix()
#' df <- data.frame(X = c(0,0,1,1,1), K = NA, M = NA, Y = c(0,0,0,1,1))
#' given <- collapse_data(df, model)[, -2]
#' make_possible_data(model, given, within = TRUE, N = 1, vars = "K")
#' make_possible_data(model, given, within = TRUE, N = 1, vars = "K")
#'
#' # Look for data on M when X = 1 and Y = 0
#' make_possible_data(model,
#'                    given,
#'                    condition =  "X == 1 & Y == 0",
#'                    vars ="M")
#'
#' model <- make_model("X->M->Y")   %>%
#'    set_parameter_matrix()
#' make_possible_data(model,
#'                    given = NULL,
#'                    N = list(3,1),
#'                    within = FALSE,
#'                    condition =  list(TRUE, "X == 1 & Y == 0"),
#'                    vars = list(c("X", "Y"), "M"))
#'
#'
#' # From book
#'
#' model <- make_model("X->M->Y")  %>%
#'  set_restrictions(c("(Y[M=1]<Y[M=0])", "(M[X=1]<M[X=0])")) %>%
#' 	set_parameter_matrix() %>%
#' 	set_parameters(type = "flat")
#'
#' 	given <-  collapse_data(data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1)),
#' 													model, remove_family = TRUE)
#' 	make_possible_data(model,
#'  	given = given,
#'  	vars = list("M", "M", "M", "M"),
#'  	within = TRUE,
#'  	N = list(1,1,1,1),
#'  	condition = list("X==0 & Y==0", "X==1 & Y==0", "X==0 & Y==1", "X==1 & Y==1"))

make_possible_data <- function(model,
															 given = NULL,
															 N = list(1),
															 within = TRUE,
															 condition = list(TRUE),
															 vars = NULL,
															 prefix = NULL) {

	if(is.null(vars)) vars <- list(model$variables)

	if(is.null(given) & within) {message("No data given; 'within' changed to FALSE"); within <- FALSE}
	if(!is.null(given)) if(!identical(names(given), c("event", "count"))){
		stop("'given' df should have two columns: event and count")}

	if(!identical(length(condition), length(N)) )
		stop("N, and conditions  must have the same length")

	if(length(vars)==1 & (length(N)>1)) vars <- rep(vars, length(N))

	if(!identical(length(vars), length(N)) )
		stop("Vars should be of length 1 or else have the same length as conditions  and N")

	g_df <- gbiqqtools:::make_possible_data_single(model,
																						given = given,
																						within = within,
																						N = N[[1]],
																						condition = condition[[1]],
																						vars = vars[[1]] )

	if(length(N) == 1){
		attr(g_df, "possible_data_args") <- list(N = N,within = within, condition = condition, vars = vars)
		return(g_df)
	}


	for (i in 2:length(N)){
		possible <-
			data.frame(select(g_df, event), count = 1) %>%
			expand_data(model) %>%
			filter(eval(parse(text = condition[[i]]))) %>%
			collapse_data(model, remove_family = TRUE)

		# where is searching possible
		available <- g_df$event %in% possible$event[possible$count>0]
		use_this  <- g_df[available,] >= N[[i]]
		if(nrow(use_this) > 1) use_this <- apply(use_this, 2, any)
		use_data <-  g_df[,use_this]

		# FLAG: Used to figure out relevant set of row labels for admissible events
		# skip     <-  data.frame(dplyr::select(g_df, event), g_df[,!use_this ])
		# if(ncol(skip)>1) names(skip)[2:ncol(skip)] <-  names(g_df)[!use_this]

		# Avoid running make_possible_single if there is insufficient data to allocate N
		if(all(!use_this[2:ncol(g_df)])){
			message(paste0("Not enough units to allocate N = ",N[[i]], " in step ",i))
			return(g_df)
		}

		out <- lapply(2:ncol(use_data), function(s) {
			use_df <-  use_data[,c(1,s)]
			names(use_df)  <- c("event", "count")
			data_single <- make_possible_data_single(model,
																							 given = 	use_df,
																							 within = TRUE,
																							 N     = N[[i]],
																							 condition = condition[[i]],
																							 vars  = vars[[i]])

			colnames(data_single)[2:ncol(data_single)] <- paste0(s-1, "-", colnames(data_single)[2:ncol(data_single)])
			data_single
		})

		out   <- Reduce(function(x, y) merge(x, y,  by = c("event"), all = TRUE), 	out)
		# out   <- merge( skip, out,  by = c("event"), all = TRUE)
		# out   <- merge(g_df, out,  by = c("event"), all = TRUE)
		g_df  <- dplyr:::mutate_if(out, is.numeric, ~replace(., is.na(.), 0))

	}

	if(!is.null(prefix)) names(g_df)[-1] <- paste0(prefix, "_", names(g_df)[-1])
	return(g_df)
}




#' Make possible data for a single strategy step
#'
#' Creates a database of possible data from a data strategy.
#' Users can gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"). Or they can
#' gather data in all cases within a given dataset ("within"). Or they can specify  the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#'
#' @param model A causal model as created by \code{make_model}
#' @param given A data frame in compact form with first column indicating event type and second column indicating number of events of that type.
#' @param N Number of variables to seek
#' @param within logical Whether to seek variables within existing data
#' @param condition  A list of character strings indicating for which cases data should be gathered. Options are: (i) to gather additional data on variables specified via \code{vars} for any possible cases in the model ("any"), (ii) to gather data in all cases within a given dataset ("within"), or (iii) to specify the subset of cases for which within-case data should be collected (e.g. "Y == 1").
#' @param vars Variables to be sought or NA. If NA \code{make_possible_data} gathers data on all variables containing NA for the specified data strategy.
#' @export
#' @return A dataset
#' @examples
#' library(dplyr)
#' model <- make_model("X->M->Y")  %>%
#'    set_restrictions(c("Y[M=1]<Y[M=0]", "M[X=1]<M[X=0]")) %>%
#'    set_parameter_matrix()
#' df <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
#' given <- collapse_data(df, model, remove_family = TRUE)
#'
#' # Look for data on M for all possible cases in the given data
#' make_possible_data_single(model, N = 0)
#' make_possible_data_single(model, N = 2)
#' make_possible_data_single(model, given = given, vars = "M", within = TRUE, N = 2)
#' make_possible_data_single(model, given = given,
#'                           within = TRUE, vars = "M",
#'                           N = 2,
#'                           condition = "X==1 & Y==1")
#'
#' model <- make_model("X -> M -> Y <- K")  %>%
#'    set_restrictions(causal_type_restrict = "(Y[M=1, K= .]<Y[M=0, K= .]) | M[X=1]<M[X=0] ") %>%
#'    set_parameter_matrix()
#' given <- data.frame(X = c(0,0,0,1,1,1), K = NA,  M = NA, Y = c(0,0,1,0,1,1)) %>%
#'          collapse_data(model = model, remove_family = TRUE)
#' make_possible_data_single(model, given = given,
#'                           within = TRUE,
#'                           N = 2,
#'                           condition = "X==1",
#'                           vars = "M")
#'
#' make_possible_data_single(model, given = given,
#'                           within = TRUE,
#'                           N = 2,
#'                           condition = "X==1 & Y==1",
#'                           vars = c("M", "K"))
#'
#'model <- make_model("X->M->Y")  %>%
#' set_restrictions(c("Y[M=1]<Y[M=0]", "M[X=1]<M[X=0]")) %>%
#' set_parameter_matrix()
#' given <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1)) %>%
#'          collapse_data(model, remove_family = TRUE)
#' make_possible_data_single(model,
#'                           given = given,
#'                           within = TRUE,
#'                           vars = "M",
#'                           N = 1,
#'                           condition = "X==1 & Y==1")
#' make_possible_data_single(model,
#'                           given = given,
#'                           within = TRUE,
#'                           vars = "M",
#'                           N = 1,
#'                           condition = "X==1")

make_possible_data_single <- function(model,
																			given = NULL,
																			N = 1,
																			within = FALSE,
																			condition = TRUE,
																			vars = NULL) {


	if(is.null(vars) & within) stop("Please specify vars to be examined")

	if(within & is.null(given)) stop("If 'within' is specified 'given' must be provided")

	if(N==0 & within) return(given)
	if(N==0 & within) return(gbiqq:::minimal_event_data(model)[, c("event", "count")])

	# If not within simply select possible data
	if(!within) return(gbiqqtools:::all_possible(model, N, vars) %>% dplyr::select(-count))

	# Otherwise its more complicated: select from *within* available data
		if(is.null(given)) stop("given not provided, but 'within' requested")

		all_event_types <- collapse_data(all_data_types(model), model, remove_family = TRUE)

		possible <- get_max_possible_data(model) %>%
		 filter(eval(parse(text = condition))) %>%
		 collapse_data(model, remove_family = TRUE)

		A_w      <- get_likelihood_helpers(model)$A_w

		# What is the set of types in which we can seek new data
		acceptable_bucket <- (A_w %*% possible[,"count"])>0
		acceptable_bucket <- rownames(acceptable_bucket)[acceptable_bucket]

		all_buckets <-  mutate(given,
						 capacity = ifelse(given$event %in% acceptable_bucket, count, 0))

		all_buckets$capacity <- all_buckets$count
		all_buckets$capacity[!(given$event %in% acceptable_bucket)] <-0

		if(sum(all_buckets$capacity) < N) {message("Not enough units to allocate N"); return(given)}
		strategies <- as.matrix(partitions::blockparts(all_buckets$capacity, N))
		colnames(strategies) <- 1:ncol(strategies)
		all_buckets <- cbind(all_buckets, strategies)

		# This function goes through a bucket strategy and generates all possible datasets
		# that could be produced by the strategy
		get_results_from_strategy <- function(strategy){
			buckets          <- all_buckets[all_buckets$capacity>0 ,]
			buckets          <- buckets[buckets[,strategy]>0,]
			data_list        <- lapply(1:nrow(buckets), function(j)   fill_bucket(model, buckets, vars, row = j, column = strategy))
			b_names          <- sapply(1:nrow(buckets), function(b_i) (all_buckets$event %in% buckets$event[b_i])*(ncol(data_list[[b_i]])-2))
			# addresses        <- do.call(rbind, lapply(apply(b_names, 2, perm),function(b)data.frame(b)+1))
			# addresses        <- apply(addresses, 1, paste, collapse = ".")
			strategy_results <- Reduce(function(x, y) merge(x, y,  by = "event", all = TRUE), data_list)
			out              <- merge(given, strategy_results,  by = "event", all = TRUE ) %>%
				                  dplyr::mutate_at(vars(-c("event", "count")),  list(~ dplyr::coalesce(., count))) %>%
				                  dplyr::select(-count)

			colnames(out)[-1] <- paste0(strategy-3, "-", 1:(ncol(out) - 1))
			out

			# colnames(out)[3:ncol(out)] <- paste0(strategy-3, "-",addresses)
			# Hack --avoid column names duplicates
			# dups <- colnames(out)[duplicated(colnames(out))]
			# l_dups <- length(dups)
			# if(l_dups > 0) colnames(out)[duplicated(colnames(out))] <- paste0(dups, "_",seq_len(l_dups))

		}

		# Run over all strategies
		all_strategies <- sapply(4:ncol(all_buckets), function(s) get_results_from_strategy(s),
														 simplify = FALSE)
		all_strategies <-	Reduce(function(x, y) merge(x, y,  by = "event", all = TRUE), all_strategies) %>%
			                mutate_if(is.numeric, ~replace(., is.na(.), 0))
		possible_data  <- merge(dplyr::select(given, event), all_strategies,  by = "event", all = TRUE)

		# Add strategies
		possible_data <- dplyr::select(all_event_types, -count) %>%
		                 merge(possible_data, by = "event") %>%
 		                 mutate_if(is.numeric, ~replace(., is.na(.), 0))

	  possible_data
}

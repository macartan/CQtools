% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_possible_data.R
\name{make_possible_data}
\alias{make_possible_data}
\title{Make data for multi-step strategy}
\usage{
make_possible_data(
  model,
  observed = NULL,
  N = list(1),
  withins = TRUE,
  conditions = list(TRUE),
  vars = NULL,
  prefix = NULL,
  unique = TRUE
)
}
\arguments{
\item{model}{A \code{causal_model}. A model object generated by \code{\link[CausalQueries]{make_model}}}

\item{observed}{A data.frame with observations.}

\item{N}{An integer. Number of node to seek.}

\item{withins}{A list of logicals. Whether to seek node within existing data. Defaults to TRUE.}

\item{conditions}{A list of character strings indicating for which cases data should be gathered. Options are: (i) to gather additional data on node specified via \code{vars} for any possible cases in the model ("any"), (ii) to gather data in all cases within an observed dataset ("within"), or (iii) to specify the subset of cases for which within-case data should be collected (e.g. "Y == 1").}

\item{vars}{A character vector. Variables to be sought or NA. If NA \code{make_possible_data} gathers data on all node containing NA for the specified data strategy.}

\item{prefix}{for columns of output; useful if multiple dataframes are later merged}

\item{unique}{= TRUE  If same data is gathered via different routes it still only gets represented once}
}
\value{
A dataset with columns: event, strategy, plus possibly multiple cases profiles
}
\description{
Creates a database of possible data from a data strategy.
Users can gather additional data on node specified via \code{vars} for any possible cases in the model ("any"). Or they can
gather data in all cases within an observed dataset ("within"). Or they can specify  the subset of cases for which within-case data should be collected (e.g. "Y == 1").
}
\examples{
model <- make_model("X->M->Y")  \%>\%
   set_restrictions(c("Y[M=1]<Y[M=0]"), "(M[X=1]<M[X=0] ") \%>\%
   set_parameter_matrix()
df <- data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1))
observed <- collapse_data(df, model)[, -2]

# Complex *not within*
make_possible_data(model, N=list(1,2), withins = FALSE, vars = list(c("X", "Y"), c("X")), conditions = TRUE)

# Complex, sequential: not within, then within
make_possible_data(model, N=list(1,1), observed = observed,
             withins = c(FALSE, TRUE),
             vars = list(c("X", "Y"), c("M")),
             conditions = TRUE)

# Look for data on M for all possible cases in the observed data
make_possible_data(model, N = 0, within = FALSE)
make_possible_data(model, N = 2, within = FALSE)
make_possible_data(model, observed = observed, vars = "M", N = 2, conditions = c("X==Y"))
make_possible_data(model, observed = observed, vars = "M", N = list(1,1), conditions = list("X==Y", "X==Y"))

# Not possible:
make_possible_data(model, observed, vars = "M", within = TRUE, N = 7)

# Partly possible: only one step completed
model2 <- make_model("A -> B -> C -> D")
observed2 <- data.frame(A = c(0,0,0,1,1,1), B = NA, C = NA, D = c(0,0,1,0,1,1)) \%>\%
  collapse_data(model2, drop_family = TRUE)
make_possible_data(model2, observed2, vars = list("B", "C"), within = TRUE, N = list(1,1), conditions = list("A==D", "A==D & B==1"))

# Within conditions
make_possible_data(model, observed, within = TRUE, N = 2, conditions = "X==1 & Y==1", vars = "M")

# Look for data on K but not M


# From book

model <- make_model("X->M->Y")  \%>\%
 set_restrictions(c("(Y[M=1]<Y[M=0])", "(M[X=1]<M[X=0])"))

	observed <-  collapse_data(data.frame(X = c(0,0,0,1,1,1), M = NA, Y = c(0,0,1,0,1,1)),
													model, drop_family = TRUE)
	make_possible_data(model,
 	observed = observed,
 	vars = list("M", "M", "M", "M"),
 	withins = TRUE,
 	N = list(1,1,1,1),
 	conditions = list("X==0 & Y==0", "X==1 & Y==0", "X==0 & Y==1", "X==1 & Y==1"))
}
